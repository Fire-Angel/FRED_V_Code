//*************************************************************
//
// Module: MSK_controller
//
// Copyright 2013 Aaron P. Dahlen
//
// APDahlen@gmail.com
//
//*************************************************************
//
//  This RTL source is free hardware: you can redistribute it 
//  and/or modify it under the terms of the GNU Lesser General  
//  Public License as published by the Free Software Foundation,  
//  either version 3 of the License, or (at your option) any 
//  later version.
//
//  This RTL source is distributed in the hope that it will be 
//  useful, but WITHOUT ANY WARRANTY; without even the implied 
//  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR   
//  PURPOSE.  See the GNU Lesser General Public License for 
//  more details.
//
//  You should have received a copy of the GNU Lesser General 
//  Public License along with this RTL source.  If not, see
//  <http://www.gnu.org/licenses/>.
//
//*************************************************************
//       ______________________________________________
//      |                                              |
//      |   MSK_controller.v                           |
//      |                                              |
//  ----| bit_clk_tick                two_bit_clk_tick |----
//      |                                              |
//  -30-| data_in                       FIFO_read_tick |----
//      |                                              |
//      |                                 PIR_mux_ctrl |----
//      |                                    reset_DDS |----
//      |                                reset_DDS_180 |----
//      |                                              |
//      |                                              |
//      |                     TESTBENCH SIGNALS:       |
//      |                                              |
//      |                                     TB_state |--8-
//  ----| clk                                 TB_count |--8-
//  ----| reset                        TB_reset_matrix |--3-
//      |______________________________________________|
//
//** Description **********************************************   
//    
//  The MSK_controller is used to generate control signals that
//  are applied to a direct digital synthesizer (DDS) to 
//  generate a Minimum Shify Keying (MSK) signal.
//
//** Instantiation ********************************************
//
//** Parameters ***********************************************
//
//** Signal Inputs: ******************************************
//
//  1) clk: high speed system clock (typically 100 MHz)
//
//  2) reset: global reset
//
//  3) bit_clk_tick:  in a MSK modulated signal transitions
//     between F1 and F2 occur once every bit clock.  For the
//     DGPS system bit_clk_tick occurs at a 100 or 200 Hz rate.
//
//  4) data_in: This is the 30-bit DGPS word to be transmitted
//     This module assumes the data is stored in a FIFO.
//
//** Signal Outputs *******************************************
//
//  1) FIFO_read_tick: This module assumes the DGPS data is 
//     cached in a FIFO.  The wire FIFO_read_tick commands the
//     FIFO to present the next data word.
//
//  2) PIR_ctrl: This signal controls an external mux which in 
//     turn selects which MSK frequency the DDS will generate.
//
//  3) reset_DDS: The DDS cannot generate the F1 and F2 
//     frequencies with 100% accuracy.  Instead, this module 
//     is designed to base timing entirely on the bit clock.
//     The F1 and F2 signals are reset on every other bit 
//     clock.  Consiquently there will NOT be slippage between 
//     the carrier and bit clock.  Note that the bit clock itself 
//     will likely be generated by a DDS.  This convoluted
//     system allows the "carrier" frequency to be adjusted
//     with all of the accuracy of the DDS and all frequencies follow...
//
//  4) Reset_DDS_180: see reset_180 - Note that the MSK DDS
//     is reset every two_bit_clock_tick.  Which is to say it is reset when
//     the signal is in or 180 degrees out of phase.
//
//  5) two_bit_clock_tick: A signal that is active every 
//     other bit clock.  This is useful to generate an
//     eye diagram.
//
//** Comments *************************************************
//
//	1) Recall that a MSK signal will be exactly in or
//     out of phase every two_bit_clocks.  This module
//     alternate between two states - after odd_slot there 
//     will be a +/- 90 degree phase shift.  At the end of 
//     even_slot the signal will have returned to +/- 180 degrees.
//
//  2) To understand the significance of 
//     {reset_DDS_next, reset_DDS_180_next} observe how the 
//     MSK signal is represented on a phase trellis diagram...
//
//** HISTORY **************************************************
//
// 08 Sep 12: Initial design & simulation using XILINX ISE 12.4
//
// 07 Mar 13: Repaired bug with reset lines plus cleanup
//
//*************************************************************

module MSK_controller(
        input wire clk,
        input wire reset,
        input wire bit_clk_tick,
        input wire [29:0] data_in,
        output wire FIFO_read_tick,
        output wire PIR_mux_ctrl,
        output reg reset_DDS,
        //output wire reset_DDS_180,
        output wire two_bit_clk,
        output wire [29:0] TB_buffer,
        output wire [4:0] TB_count,
        output wire [7:0] TB_state,
        output wire [2:0] TB_reset_matrix,
		  output wire signed [3:0] TB_reset_ctr
		  //output wire TB_reset_DDS
    );

//** CONSTANT DECLARATIONS ************************************

    /* General shortcuts */
        localparam T = 1'b1;
        localparam F = 1'b0;

//** SYMBOLIC STATE DECLARATIONS ******************************

    localparam [7:0]     
        get_data            = 8'h1,
        odd_slot            = 8'h2,
        even_slot           = 8'h4;

//** SIGNAL DECLARATIONS **************************************

    reg [7:0] state_reg, state_next;
    reg [4:0] count_reg, count_next;

    reg [29:0] buffer_reg, buffer_next;
    reg FIFO_read_tick_reg, FIFO_read_tick_next;

    reg PIR_mux_ctrl_reg, PIR_mux_ctrl_next;
   // reg reset_DDS_reg, reset_DDS_next;
    //reg reset_DDS_180_reg, reset_DDS_180_next;
 //   reg two_bit_clk_tick_reg, two_bit_clk_tick_next;

    reg odd_bit_reg, odd_bit_next;
    reg even_bit_reg, even_bit_next;
    reg last_reset_reg, last_reset_next;

    reg [5:0]count_kill_warnings;
	 
	 reg signed[3:0] reset_ctr, reset_ctr_next;
	 reg reset_DDS_next;
	 

//** INSTANTIATIONS *******************************************

//** ASSIGN STATEMENTS ****************************************

    assign PIR_mux_ctrl = PIR_mux_ctrl_reg;
//    assign reset_DDS = reset_DDS_reg;
//    assign reset_DDS_180 = reset_DDS_180_reg;
   // assign two_bit_clk_tick = two_bit_clk_tick_reg;
    assign FIFO_read_tick = FIFO_read_tick_reg;
	 assign two_bit_clk = count_reg[0];


    /* Testbench signals */

        assign TB_state = state_reg;
        assign TB_count = count_reg;
        assign TB_buffer = buffer_reg;
        assign TB_reset_matrix = {last_reset_reg, odd_bit_reg, even_bit_reg};

	 	assign TB_reset_ctr =  reset_ctr;
		assign TB_reset_DDS = reset_DDS;

//** TASKS / FUNCTIONS **************************************** 

//** BODY *****************************************************
//            ________________ 
//           |                |
//           |  Finite State  |
//    _______|    Machine     |
//    _INPUT_| with data path |
//           |                |
//           |   Next State   |       ________________
//           |      and       |______|                |
//  _________|     Logic      |_NEXT_|     State      |_______
// |  _STATE_|                |      |      and       |__OUT__
// | |       |________________|      | Data Registers |
// | |                               |                |____
// | |                         -clk-->                |__  |
// | |                               |________________|  | |
// | |                                                   | |
// | |___________________________________________________| |
// |_______________________________________________________|
//        
//
// This FSMD uses a two always block design with all outputs
// registered.  The next state logic for the registers and 
// outputs are calculated in a combinational block while the
// flip-flops holding the state and actual outputs are held
// in a sequential block.
//
// For coding consistency all next states and data path 
// elements in the combinational block are referenced 
// as foo_next.  Observe that this is a Moore machine.
//
//** FSMD STATE & DATA REGISTERS ******************************

    always @(posedge clk, posedge reset) begin
        if(reset) begin
            state_reg <= even_slot;                     	// get_data;
            count_reg <= 5'd29;                            // force "even_slot" to get data
            FIFO_read_tick_reg <= T;
            PIR_mux_ctrl_reg <= F;
//            reset_DDS_reg <= T;                       	// DDS to known position
//            reset_DDS_180_reg <= F;
            buffer_reg <= 30'b101010101010101010101011111111;   // FIX me
         //   two_bit_clk_tick_reg <= F;
            last_reset_reg <= T;
            odd_bit_reg <= F;                   			// what should this be???
            even_bit_reg <= T;                  			// System may be off for one message if they are wrong...
				reset_ctr <= F;
		      reset_DDS <= F;       
		 end  
        else begin
            state_reg <= state_next;
            count_reg <= count_next; 
            FIFO_read_tick_reg <= FIFO_read_tick_next;
            PIR_mux_ctrl_reg <= PIR_mux_ctrl_next;
//            reset_DDS_reg <= reset_DDS_next;
//            reset_DDS_180_reg <= reset_DDS_180_next;
            buffer_reg <= buffer_next;
          //  two_bit_clk_tick_reg <= two_bit_clk_tick_next;
            last_reset_reg <= last_reset_next;
            odd_bit_reg <= odd_bit_next;
            even_bit_reg <= even_bit_next;
				
				reset_ctr <= reset_ctr_next;
		      reset_DDS <= reset_DDS_next;
				
    end end

//** FSMD NEXT STATE and LOGIC ********************************

    always@* begin
        state_next = state_reg;
        count_next = count_reg;

        FIFO_read_tick_next = F;
        PIR_mux_ctrl_next = PIR_mux_ctrl_reg;
        reset_DDS_next = F;
//        reset_DDS_180_next = F; 
        buffer_next = buffer_reg;
      //  two_bit_clk_tick_next = F;

        odd_bit_next = odd_bit_reg;
        even_bit_next = even_bit_reg;
        last_reset_next = last_reset_reg;
		  
		  reset_ctr_next = reset_ctr;
		  reset_DDS_next = F;

        case (state_reg)  

            even_slot: begin
                if (bit_clk_tick == T) begin
					 

//						  if (reset_ctr == -1)begin
//								reset_DDS_next = T;
//					     end
						  
						  
              //      two_bit_clk_tick_next = T;
                    PIR_mux_ctrl_next = buffer_reg[0];
                    even_bit_next = buffer_reg[0];
						  
						  if(buffer_reg[0] == T) begin
								reset_ctr_next = reset_ctr + 1;
								if (reset_ctr == 3)begin
								    reset_ctr_next = 0;
									 reset_DDS_next = T;
								end else if (reset_ctr == -1)begin
							      reset_DDS_next = T;
							   end

						  end else begin
								reset_ctr_next = reset_ctr - 1;
							   if (reset_ctr == -3)begin
								    reset_ctr_next = 0;
									 reset_DDS_next = T;
								end else if (reset_ctr == 1)begin
							       reset_DDS_next = T;
									 end
								end
								

                    buffer_next = {1'b0,buffer_reg[29:1]}; 	// buffer_reg >> 1;
                    count_next = count_reg + 4'd1; 			// count_reg[4:0] + 1;

                   // if(count_next < 8'd30) begin
                   //     state_next = odd_slot;
                   // end 
						 
						 if(count_next >= 8'd30) begin

                      //  state_next = odd_slot;

                        buffer_next = data_in;      			// capture data
                        FIFO_read_tick_next = T;    			// signal FIFO to advance
                        count_next = 0;

                    end

//                    case ({last_reset_reg, even_bit_reg, odd_bit_reg })
//
//                        3'b000: {reset_DDS_next, reset_DDS_180_next} = 2'b10;
//                        3'b001: {reset_DDS_next, reset_DDS_180_next} = 2'b01;
//                        3'b010: {reset_DDS_next, reset_DDS_180_next} = 2'b01;
//                        3'b011: {reset_DDS_next, reset_DDS_180_next} = 2'b10;
//
//                        3'b100: {reset_DDS_next, reset_DDS_180_next} = 2'b01;
//                        3'b101: {reset_DDS_next, reset_DDS_180_next} = 2'b10;
//                        3'b110: {reset_DDS_next, reset_DDS_180_next} = 2'b10;
//                        3'b111: {reset_DDS_next, reset_DDS_180_next} = 2'b01;
//
//                        default: {reset_DDS_next, reset_DDS_180_next} = 2'b00;
//                    endcase

                last_reset_next = reset_DDS_next;  			// save for next

            end end

   //         get_data: begin
   //
   //             buffer_next = data_in;      					// capture data
   //             FIFO_read_tick_next = T;    					// signal FIFO to advance
   //             count_next = 0;             					// DGPS sends 30-bit words

   //             state_next = odd_slot;
   //         end   

            odd_slot: begin
                if (bit_clk_tick == T) begin
					 
					 	 reset_ctr_next = reset_ctr - 1;
						  if (reset_ctr == -3)begin
						      reset_ctr_next = 0;
								reset_DDS_next = T;
					     end
//						  if (reset_ctr == 1)begin
//								reset_DDS_next = T;
//					     end
					 
                    PIR_mux_ctrl_next = buffer_reg[0];
                    odd_bit_next = buffer_reg[0];

                    buffer_next = {1'b0,buffer_reg[29:1]};  // shift right  //   //>> 1;
                    count_kill_warnings = count_reg + 1;
                    count_next = count_kill_warnings[4:0];
                    state_next = even_slot;
            end end

            default: state_next = odd_slot;

         endcase  

    end
	 
	 
// Reset logic:	 
	
//	reg signed[2:0] reset_ctr;
//	
//	always @(posedge clk, posedge reset) begin
//	
//		if(reset)
//			reset_ctr <= 0;
//		else if(bit_clk_tick) begin
//		    if (buffer_reg[0] == T)
//			   
//				reset_ctr <= reset_ctr + 1;
//		    else (reset_ctr <= reset_ctr - 1);
//		end
//	
//
//
//	end
	 

endmodule 
